\documentclass[a4paper]{article}
%\documentclass[gmd]{copernicus}
%\documentclass[article,nojss]{jss}
%\VignetteIndexEntry{TimeMap GeneralModel}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Add-on packages and fonts
%\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{Sweave}
\usepackage{color}
\usepackage[round]{natbib}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
%\newcommand{\R}{\proglang{R }}
\newcommand{\R}{\textsf{R }}
\newcommand{\SoilR}{\texttt{SoilR}}
\newcommand{\FME}{\texttt{FME}}
\newcommand{\GeneralModel}{\texttt{GeneralModel}}
\newcommand{\Model}{\texttt{Model}}
\newcommand{\TimeMap}{\texttt{TimeMap}}
\newcommand{\codestyle}[1]{{\texttt{#1}}}
\newcommand{\figref}[1]{Fig: \ref{#1}}


\title{Estimating Parameters of Compartment Models in \SoilR: }
%\Plaintitle{Implementing Compartment Models in \SoilR}

%\keywords{organic matter decomposition, compartment models, 
%          linear dynamical systems}

\author{Markus M\"uller\thanks{mamueller@bgc-jena.mpg.de} \ 
     and Carlos A. Sierra\thanks{csierra@bgc-jena.mpg.de} \\ 
         Max Planck Institute for \\
         Biogeochemistry }


\begin{document}
\maketitle
\SweaveOpts{engine=R,eps=FALSE}
\SweaveOpts{keep.source=TRUE}

\abstract{
The objective of this vignette is to provide an example on how to use \SoilR \, to interface with package \FME \,
in order to estimate parameters of soil organic matter decomposition models using observed 
data.
To this end we set the following task: to identify a mathematical structure that best represent some observed data of carbon stocks, fluxes and/or their isotopic composition.  The target model should fulfill the following requirements.
\begin{enumerate}
    \item It can reproduce the overall time behavior of the data.
    \item Its  parameters can be determined by the data with sufficient accuracy.
\end{enumerate}
We will not explain \FME \, functionality here, but strongly recommend to read the vignette for package \FME.
Instead, we focus here on the application to the models implemented in \SoilR. 
%However, it is not necessary to read any other \SoilR vignette before this one.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The data}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Assume the  following data have been measured. 
\begin{enumerate}
    \item
        The $\Delta^{14}C$ of soil respiration at some points in time.
    \item
        The carbon content in two soil fractions measured over time.
    \item
        The total amount of carbon entering the soil over time.
    \item
        A time series of the atmospheric  $\Delta^{14}C$ starting from 1990 to 2010.
\end{enumerate}
The data used for these examples are provided as part of \SoilR.
Uncommenting the following code shows all datasets that come with the package.
<<echo=F,print=FALSE>>=
library(SoilR)
@
<<echo=true,print=FALSE>>=
#library(SoilR)
#data(package="SoilR")
@
We load the following:
<<echo=true,print=FALSE>>=
data(CourseExample_R14)
data(C14Atm_NH)
@
The following code plots the data.

\begin{figure}
<<echo=T,fig=T,print=FALSE>>=
     #define a small helper function
     bars=function(x,y,err,...){
        points(x,y,...)
        arrows(x,y-err,x,y+err,code=3,angle=90,...)
     }
     data(CourseExample_R14)
     c1="black"
     c2="red"
     x=DataC$time
     xl=min(x);xu=max(x);os=0.05*(xu-xl); xlimits=c(xl-os,xu+os)
     y1=DataC$C1
     y2=DataC$C2
     err=DataC$sd
     ylimits=range(y1+err,y2+err,y1-err,y2-err)
     #draw empty field
     plot(NA, xlim=xlimits, ylim=ylimits)
     w=3
     #draw the error arrow
     bars(x,y1,err,col=c1,lwd=w)
     bars(x,y2,err,col=c2,lwd=w)
     
@
\end{figure}


\begin{figure}
<<echo=T,fig=T,print=FALSE>>=
     x=DataR14$time
     xl=min(x);xu=max(x);os=0.05*(xu-xl); xlimits=c(xl-os,xu+os)
     y=DataR14$R14t
     err=DataR14$sd
     ylimits=range(y-err,y+err)
     #draw empty field
     plot(NA , xlim=xlimits , ylim=ylimits)
     w=3
     #draw the error arrow
     bars(x,y,err,col=c1,lwd=w)
@
\end{figure}


\begin{figure}
<<echo=T,fig=T,print=FALSE>>=
     x=DataI$time
     xl=min(x);xu=max(x);os=0.05*(xu-xl); xlimits=c(xl-os,xu+os)
     y=DataI$In
     err=DataI$sd
     ylimits=range(y-err,y+err)
     #draw empty field
     plot(NA , xlim=xlimits , ylim=ylimits)
     w=3
     #draw the error arrow
     bars(x,y,err,col=c1,lwd=w)
@
\end{figure}


\begin{figure}
<<echo=T,fig=T,print=FALSE>>=
     x=C14Atm_NH$YEAR
     y=C14Atm_NH$Atmosphere
     plot(x,y,lwd=w)
@
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Available Models}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\SoilR \, provides a very general approach to model soil organic matter decomposition and can therefore be used for a wide range of applications. 
Many models, especially those that are frequently used in the literature, have been implemented on top of the general framework making them even easier to use. 
To see what is in the package uncomment the following code,
<<echo=true,print=true>>=
#?Models
@
which will show all the currently available functions for the construction of models.
In our case we look for those that start with \codestyle{Twop..}, which abbreviates \emph{two pool} and end with \codestyle{..14}, which marks the $^{14}C$ model constructors but also you may consider more general cases.
The candidates are thus: 
\begin{enumerate}
        \item
        TwopParallelModel14
        \item
        TwopSeriesModel14
        \item
        TwopFeedbackModel14
        \item
        GeneralModel14
\end{enumerate}
In thoery all these models could potentially describe the data, which is our first request. 
A closer look at the help pages of these candidates reveals that the number of parameters 
to choose increases from top to bottom. Thus the difficulty to \emph{constrain} the parameters will
increase also. 
It is convenient to start with the \codestyle{twopParallelModel14} 
and assume only the two decay constants of the pools as variable parameters. 
As we proceed we can allow more parameters to be varied and evaluate the increase in model performance.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Synthesis}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Our first aim is to reproduce a synthetic dataset as function of the parameters to be determined.
In a second step, we have to provide a measure for the disagreement between the synthetically produced data 
and the real data. The deviation between predictions and observations will be computed by an \emph{objective} or \emph{cost} function.
Then, we have to try different combinations of the free parameters in order to minimize the objective function.
The \FME \, package will be very useful for steps two and three, while we will use \SoilR \, for the first step.
A look at the help page of \codestyle{twopParallelModel14} shows which arguments we have to provide. 
We start with those that we consider fixed. 
\begin{itemize}
    \item 
        We begin with the time steps where we want to compute the solution.
        Since we want to compare the output to the observed data later it is reasonable to compute values 
        at least for the times given in our dataset. 
<<echo=true,print=False>>=
library("SoilR")
library("FME")
t_start=1978
t_end=2008
#t_start=t_end-30
indices=(C14Atm_NH$YEAR>=t_start & C14Atm_NH$YEAR < t_end)
time=C14Atm_NH$YEAR[indices]
@
    \item
We proceed with the initial values, which we can extract from the data.
<<echo=true,print=T>>=
C0=as.numeric(DataC[1,c("C1","C2")])
@
    \item
        The next item is the inputrate which is part of the data set and can be passed directly.
    \item
        The parameter $\gamma$, which represents the partitioning of the inputs to the two different pools, will be held constant. 
<<echo=true,print=F>>=
gam=0.6
@
    \item
    $\xi$, a parameter used to describe the influence of temperature and moisture on decomposition as function of time will be held constant as well.
<<echo=true,print=F>>=
xi=1
@
    \item
The dataset of atmospheric $\Delta^{14}C$ values will be used directly as an argument for \codestyle{FcAtm}.
    \item
The untis of the radioactive decay constant $\lambda$ must be compatible with our time unit. We compute it here from the Libby half-life given in years.
\SoilR \, would use the same value as default, so this preparation is really needed only if you decide to use another unit for time measurement.
<<echo=true,print=T>>=
th=5730
#note that lambda is negative and has the unit y^-1
lambda=log(0.5)/th 
@
\end{itemize}
The remaining part of the model construction we wrap into a function that depends on the 
unknown parameters $k_1$ and $k_2$ and the parameter \codestyle{pass} only.
The \codestyle{pass} argument requires some explanation. It only makes sense in view of the future use of our small function with \FME.
The reason is this:
If you create a model in \SoilR \, the package will by default execute a number of tests on the given arguments to prevent the unintentional creation of models that are not biologically meaningful.
Unfortunately \FME 's algorithms do not care about biologically meaningful parameter combinations and would cause \SoilR \, to exit with an error if by chance such a combination occurs.
It might for instance happen that during the fitting procedure \FME \, tries a positive value of $k$ to fit the data, which would mean \emph{creation} of organic matter instead of \emph{decomposition}. 
The interface of \codestyle{modFit} provides only one possibility 
to avoid this situation by setting appropriate upper and lower bounds for parameters. 
This would do the job with this simple example but not for all cases. 
\emph{For those cases only} we introduce the \codestyle{pass} facility used as a last resort 
to switch off the checking at model creation.
If we do so we have to check the estimated parameters afterwards without this flag.
We will do this at the end of this example.
For the moment, note that we allow for an additional argument to turn off the internal checking by setting \codestyle{pass=TRUE}. 
<<echo=true,print=F>>=
pf<-function(ks,pass=FALSE){
    mod=TwopParallelModel14(
            time,
            ks,
            C0,
            In=DataI,
            gam=gam,
            xi=xi,
            FcAtm=C14Atm_NH,
            lambda=lambda,
            pass=pass
    ) 
    Cs=getC(mod)
    R14t=getTotalReleaseFluxC14CRatio(mod)
    return(data.frame(time=time,R14t=R14t,C1=Cs[,1],C2=Cs[,2]))
}
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%<<echo=False,print=False>>=
%# this invisible section is used to create a new dataset
% t_end=2008
% t_start=t_end-30
% data(C14Atm_NH)
% indices=(C14Atm_NH$YEAR>=t_start & C14Atm_NH$YEAR < t_end)
% time=C14Atm_NH$YEAR[indices]
% C0=c(0.5,0.5) 
% 
% l=length(time)
% iC=seq(1,l,4)
% In=rep(0.05,length(iC))
% stdIn=0.05*max(In)
% errIn=rnorm(sd=stdIn,n=length(In))
% DataI <- data.frame(
%     time=time[iC],
%     In  =  In+errIn
%     ,
%     sd=stdIn
% )
% pars=c(k1=-0.3,k2=-0.5)
% Df=pf(pars)
% #Now we first select a view points, disturb the data and plot it \figref{fig:distdata}. 
% iR14=seq(1,l,8)
% #iR14=c(1,l)
% stdC=0.2*max(Df$C1)
% std14=0.2*max(Df$R14t)
% errR14=rnorm(sd=std14,n=length(iR14))
% errC1=rnorm(sd=stdC,n=length(iC))
% errC2=rnorm(sd=stdC,n=length(iC))
% DataR14 <- data.frame(
%     time=time[iR14],
%     R14t=Df$R14t[iR14]+errR14,
%     sd=std14
%     )
% DataC <- data.frame(
%     time=time[iC],
%     C1  =  Df$C1[iC]+errC1,
%     C2  =  Df$C2[iC]+errC2,
%     sd=stdC
% )
% #the next line has to be commented out for the real vignette
% datadir="/home/mm/SoilR/RPackages/SoilR/pkg/data/"
% save(DataR14,DataC,DataI,file=paste(datadir,"CourseExample_R14",".rda",sep=""),ascii=TRUE)
% save(DataR14,file=paste(datadir,"DataR14",".rda",sep=""),ascii=TRUE)
% save(DataC,file=paste(datadir,"DataC",".rda",sep=""),ascii=TRUE)
% save(DataI,file=paste(datadir,"DataI",".rda",sep=""),ascii=TRUE)
%@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
We produce a dataset of arbitrarily chosen parameters $k_1$ and $k_2$  and plot it together with the data:
\begin{figure}[h]
\label{fig:distdata3}
<<echo=T,fig=TRUE,print=F>>= 
pars=c(k1=-0.1,k2=-0.2)
Df=pf(pars)
c1="black"; c2="red";lty1=1;lty2=2
plot(DataC[,"time"],
     DataC[,"C1"],
     col=c1,lty=lty1,
     xlab="time",
     ylab="C content of the pools"
)
points(
       DataC[,"time"],
       DataC[,"C2"],
       col=c2,
       lty=lty1
)
lines(Df$time,Df$C1,col=c1,lty=lty1)
lines(Df$time,Df$C2,col=c2,lty=lty1)
legend("topright",
       legend=c("C content of pool 1","C content of pool 2"),
       col=c(c1,c2)
      # ,lty=c(lty1,lty2)
       ,bty="n")
@
\caption{The output for the C stock of a model with arbitrarily chosen parameters $k_1$ and $k_2$ together with the observed data.}
\end{figure}
\begin{figure}
<<fig=TRUE>>= 
plot(DataR14[,"time"],DataR14[,"R14t"],lty=1,col=c1,
     xlab="Years",ylab=expression(paste(Delta^14,"C "," in respiration (permil)")))
lines(Df$time,Df$R14t,col=c1,lty=lty1)
@
\caption{The modeled $\Delta^{14}C$ fraction of the respiration of a model with arbitrarily chosen parameters $k_1$ and $k_2$ together with the (measured) data}.
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\clearpage

To give \FME \, a tool to measure the quality of a parameter combination we need
a cost function that weights the error. 
Since in this example we deal
with two different kinds of data that have different units and have a different
number of data points we have to invest some time for thought here.  
\begin{enumerate}
    \item
        We apply \FME 's \codestyle{modCost} twice, the first time on data arguments only but the
second time with the additional argument of the first cost function.
This expresses the fact that we treat errors of different observables differently. 
    \item
  The weighing is done by dividing the residuals by the error which is done for two reasons: first to get a dimensionless result and second to reduce the influence of uncertain values.  The errors are assumed to be in  column with name "sd" of the measured dataset.  
    \item
        We could suppress the weight of  the spare $\Delta^{14}C$ values by the  more frequent C
        measurements by rescaling the cost function according to the number of data points, which could be done with
        the \codestyle{scaleVar} argument.
\end{enumerate}

\begin{figure}
%<<echo=true,print=False,fig=TRUE>>=
<<echo=true,print=False,fig=TRUE>>=
    DfCost <- function(pars){
        Df <- pf(pars,pass=TRUE)
        Ccost=modCost(
                    model=Df,
                    obs=DataC,
                    err="sd"
                    #,scaleVar=TRUE
                    )
        return(
               modCost(
                       model=Df,
                       obs=DataR14,
                       err="sd",
                       #,scaleVar=TRUE
                       cost=Ccost)
               )
    }
    plot(DfCost(pars),xlab="time")
@
    \caption{The (error) weighted residuals.}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\clearpage
Since we now have a measure for the cost we can use fully \FME \, functionality; e.g. determine how sensitive this cost is to changes in our parameters, which helps us to detect unidentifiable parameters. 
To do so we  create the sensitivity functions.
We also can estimate the approximate linear dependence (collinearity) of the two parameters which reveals parameters that have similar effect on the output and are hard to identify simultaneously. 
All this is \FME \, functionality and is described in much more detail by \FME 's vignettes. 
\begin{figure}
<<echo=true,print=FALSE,fig=TRUE>>=
Sfun <- sensFun(DfCost,pars)
summary(Sfun)
plot(Sfun,which=c("R14t","C1","C2"),xlab="time",lwd=2)
@
    \caption{The plot shows the sensitivity functions of all three observables on both parameters.
    The result is an extreme case and shows that in a parallel model the C stock of pool 1 does not depend on $k_2$ and vice versa, while the overall respiration naturally depends on both variables}
\end{figure}

\begin{figure}
<<echo=true,print=FALSE,fig=TRUE>>=
pairs(Sfun,which=c("R14t","C1","C2"),col=c("green","blue","red"))
@
    \caption{The pairs plot summarizes the dependency of the sensitivity function of all three observables on both parameters. It would also reveal collinearity if the points of different colors were showing a similar pattern which they fortunately do not in this example.
    The alignment of the blue and red clouds to the axis expresses the same lesson that we learnt from the plot of the sensitivity functions: In a parallel model the  C stock of pool 1 does not depend on $k_2$ and vice versa}
\end{figure}
%\clearpage
We can estimate the collinearity explicitly: 
<<echo=true,print=true>>=
ident <- collin(Sfun,parset=c("k1","k2"))
@

Finally we fit the parameter to the data. 
Before we do so we always have to think about how to prevent the creation of invalid models.
The only way provided by \codestyle{modFit} is to constrain parameter ranges by upper and lower bounds. 
Whether this will constrain \FME 's guesses to the reasonable parameter values depends on our ability to choose the appropriate parameter set. 
However to give \FME \, algorithms the freedom to (temporarily) test even (biologically) unreasonable values we deliberately disabled \SoilR's checks during the creation of models in the cost function.
To demonstrate that with \codestyle{pass} set to true the parameter estimation works even for biologically meaningless parameters we deliberately choose a positive start value for one of the decay constants and also a to large parameter range to include this value. (For a valid model both decay constants would have to be smaller than zero since positive values do not refer to decomposition but "growth".) 
\begin{figure}
<<echo=true,print=FALSE,fig=TRUE>>=
    Fit <- modFit(f=DfCost,upper=c(0.2,0),p=c(0.1,-0.1))
    print(Fit$par) 
    plot(Fit)
    summary(Fit)
@
    \caption{The plot shows how the residuals have been minimized by the fitting procedure and 
    can be used to inspect convergence of the algorithm}
\end{figure}
We compare the fitted curve to the curve resulting from the values that were used to create the example dataset in the first place. 
To this end we create again the model with the estimated parameter values, this time without the \codestyle{pass} argument to use \SoilR's checks.
So we are sure that the best numerical fit is also biologically possible.
\begin{figure}
<<echo=true,print=FALSE,fig=TRUE>>=
Dfinal=pf(Fit$par)
allval=rbind(Df[,c("C1","C2")],Dfinal[,c("C1","C2")],DataC[,c("C1","C2")])
    plot(Df$time,Df$C1, type="l", lty=lty2,
         ylim=c( min(allval) ,max(allval)),
         col=c1)
    lines(Df$time,Df$C2,lty=lty2,col=c2)
    lines(Dfinal$time,Dfinal$C1,lty=lty1,col=c1)
    lines(Dfinal$time,Dfinal$C2,lty=lty1,col=c2)
    points(
           DataC[,"time"],
           DataC[,"C1"],
           col=c1,
           lty=lty1
    )
    points(
           DataC[,"time"],
           DataC[,"C2"],
           col=c2,
           lty=lty1
    )
legend("topright",
       legend=c(
                 "pool 1 initial"
                ,"pool 2 initial"
                ,"pool 1 final"
                ,"pool 2 final"
                ),
       col=c(c1,c2,c1,c2),lty=c(lty2,lty2,lty1,lty1),bty="n")
@
    \caption{The arbitrary initial guess and the final solution}
\end{figure}
\begin{figure}
<<echo=true,print=FALSE,fig=TRUE>>=
    plot(Df$time,Df$R14t,type="l",lty=lty1,col=c1)
    lines(Dfinal$time,Dfinal$R14t,lty=lty2,col=c2)
@
\end{figure}
%% begin Bayesian part
%Usually we are not only interested in the best fitting parameters, but rather in the distribution of the parameters. We can estimate them with the Monte Carlo Markov Chain method that is also part of \FME.  
%Once again we refer to the \FME 's vignette for details.
%\begin{figure}
%<<echo=true,print=false,fig=true>>=
%    #var0 <- Fit$var_ms_unweighted
%    #cov0 <- summary(Fit)$cov.scaled#*2.4^2/5
%    #p=Fit$par
%    niter=500
%    t1=Sys.time()
%    MCMC  <- modMCMC(f=DfCost,niter=niter,p=Fit$par)
%    t2=Sys.time()
%
%    print(t1-t2)
%    summary(MCMC)
%    plot(MCMC, Full = TRUE)
%@
%    \caption{The plot shows the accepted values for each parameter. It can be used to identify situations where there is doubt if the collected values represent the equilibrium distribution of the chain}
%\end{figure}
%\begin{figure}
%<<echo=true,print=false,fig=true>>=
%    sR=sensRange(func=pf, parInput=MCMC$par)
%    plot(summary(sR)
%         ,xlab="Years"
%     )
%@
%    \caption{The plot shows the range for the model output based on the estimated 
%    distribution of the parameters }
%\end{figure}
%
%\begin{figure}
%<<echo=true,print=false,fig=true>>=
%    pairs(MCMC, nsample = niter/4)
%@
%    \caption{This plot is the analogon of the pairs plot for the sensitivity}  
%\end{figure}


\clearpage
%\bibliographystyle{abbrvnat}
\bibliography{../../../../../doc/SoilRv1/SoilR.bib}
\end{document}
